// 函数: sub_630069
// 地址: 0x630069
// 来自: E:\Download\Various Files\CLANNAD HD Edition\CLANNAD\SiglusEngine_Steam.exe

*arg1 += arg1.b
wchar16 const* const var_4 = u"mask"
arg2[-6] = 0
arg2[-0xa].w = arg1.w
sub_52e720(&arg2[-0xa], var_4, __return_addr)
arg2[-1] = 5
void* eax = data_bac510
arg2[-0x17] = 1
arg2[-0x36] = 0x87
int32_t var_8 = *(eax + 0x12750)
void* var_c = &arg2[-0xa]
void** var_90
__builtin_memcpy(&var_90, &arg2[-0x36], 0x80)
int32_t var_8c
void* entry_ebx
sub_631d40(entry_ebx + 0x569d8, var_90, var_8c)
arg2[-1] = 0xffffffff

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

arg2[-0xb] = 7
void* const var_4_1 = &data_ad7c90
arg2[-0xc] = 0
arg2[-0x10].w = 0
sub_52e720(&arg2[-0x10], var_4_1, nullptr)
arg2[-1] = 6
arg2[-5] = 7
int32_t* var_4_2 = u"stage"
arg2[-6] = 0
arg2[-0xa].w = 0
sub_52e720(&arg2[-0xa], var_4_2, 5)
void* eax_2 = entry_ebx + 0x56a90
arg2[-1].b = 7
arg2[-0x17] = 1
arg2[-0x36] = 0x31

if (eax_2 + 0xb8 != &arg2[-0x10])
    sub_52e3c0(eax_2 + 0xb8, &arg2[-0x10], 0, 0xffffffff)
    eax_2 = entry_ebx + 0x56a90

*(eax_2 + 0xd0) = 1
void var_7c
int32_t var_80 = __builtin_memcpy(&var_7c, &arg2[-0x36], 0x80)
int32_t var_84 = 0
char var_88 = 3
var_90 = &arg2[-0xa]
sub_60a340(eax_2, var_90, &arg2[-0xa], var_88)

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

arg2[-1] = 0xffffffff
bool cond:0 = arg2[-0xb] u< 8
arg2[-5] = 7
arg2[-6] = 0
arg2[-0xa].w = 0

if (not(cond:0))
    j__free(arg2[-0x10])

sub_5cd760(entry_ebx + 0x56b64)
arg2[-5] = 7
wchar16 const* const var_4_4 = u"screen"
arg2[-6] = 0
arg2[-0xa].w = 0
sub_52e720(&arg2[-0xa], var_4_4, 6)
arg2[-1] = 8
arg2[-0x17] = 1
arg2[-0x36] = 0x46
__builtin_memcpy(&var_7c, &arg2[-0x36], 0x80)
sub_5fa690(entry_ebx + 0x61f5c, &arg2[-0xa], var_7c)
arg2[-1] = 0xffffffff

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

sub_6a64d0(entry_ebx + 0x4b348)
sub_5fdee0(entry_ebx + 0x6217c)
arg2[-5] = 7
wchar16 const* const var_4_5 = u"pcmevent"
arg2[-6] = 0
arg2[-0xa].w = 0
sub_52e720(&arg2[-0xa], var_4_5, 8)
arg2[-1] = 9
void* eax_5 = data_bac510
arg2[-0x17] = 1
arg2[-0x36] = 0x34
int32_t var_8_2 = *(eax_5 + 0xa4c764)
void* var_c_1 = &arg2[-0xa]
__builtin_memcpy(&var_90, &arg2[-0x36], 0x80)
sub_631e30(entry_ebx + 0x62634)
arg2[-1] = 0xffffffff

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

arg2[-5] = 7
wchar16 const* const var_4_6 = u"editbox"
arg2[-6] = 0
arg2[-0xa].w = 0
sub_52e720(&arg2[-0xa], var_4_6, 7)
arg2[-1] = 0xa
void* eax_7 = data_bac510
arg2[-0x17] = 1
arg2[-0x36] = 0x61
void** ecx_16 = __builtin_memcpy(&var_7c, &arg2[-0x36], 0x80)
int32_t var_88_1 = *(eax_7 + 0xa4df80)
var_90 = ecx_16
sub_631f20(entry_ebx + 0x626ec, var_90, &arg2[-0xa])
arg2[-1] = 0xffffffff

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

arg2[-5] = 7
int32_t* var_4_7 = u"call"
arg2[-6] = 0
arg2[-0xa].w = 0
sub_52e720(&arg2[-0xa], var_4_7, 4)
arg2[-1] = 0xb
arg2[-0x17] = 1
arg2[-0x36] = 0x62
*(entry_ebx + 0x6285c) = 1
void* var_c_2 = &arg2[-0xa]
__builtin_memcpy(&var_90, &arg2[-0x36], 0x80)
sub_5b6750(entry_ebx + 0x627a4)
arg2[-1] = 0xffffffff

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

sub_52e820(&arg2[-0xa], u"excall")
arg2[-1] = 0xc
arg2[-0x17] = 1
arg2[-0x36] = 0x41
__builtin_memcpy(&var_7c, &arg2[-0x36], 0x80)
sub_5ba0e0(entry_ebx + 0x62860, &arg2[-0xa])
arg2[-1] = 0xffffffff

if (arg2[-5] u>= 8)
    j__free(arg2[-0xa])

*(entry_ebx + 0x4a76c) = 0
sub_52e820(&arg2[-0x16], &data_af5d3c)
arg2[-1] = 0xd
sub_684160(data_bac424, 5, &arg2[-0x16])

if (arg2[-0x11] u>= 8)
    j__free(arg2[-0x16])

char* result
result.b = 1
TEB* fsbase
fsbase->NtTib.ExceptionList = arg2[-3]
sub_745f2b(arg2[-4] ^ arg2)
*arg2
return result

// 函数: sub_630053
// 地址: 0x630053
// 来自: E:\Download\Various Files\CLANNAD HD Edition\CLANNAD\SiglusEngine_Steam.exe

bool c

if (not(c))
    j__free(arg1[-0xa])

void* var_4_2 = 4
arg1[-5] = 7
wchar16 const* const var_8 = u"mask"
arg1[-6] = 0
arg1[-0xa].w = 0
sub_52e720(&arg1[-0xa], var_8, var_4_2)
arg1[-1] = 5
void* eax = data_bac510
arg1[-0x17] = 1
arg1[-0x36] = 0x87
int32_t var_c = *(eax + 0x12750)
void* var_10 = &arg1[-0xa]
void** var_94
__builtin_memcpy(&var_94, &arg1[-0x36], 0x80)
int32_t var_90
void* entry_ebx
sub_631d40(entry_ebx + 0x569d8, var_94, var_90)
arg1[-1] = 0xffffffff

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

arg1[-0xb] = 7
void* var_4_4 = nullptr
void* const var_8_1 = &data_ad7c90
arg1[-0xc] = 0
arg1[-0x10].w = 0
sub_52e720(&arg1[-0x10], var_8_1, var_4_4)
arg1[-1] = 6
void* const var_4_5 = 5
arg1[-5] = 7
int32_t* var_8_2 = u"stage"
arg1[-6] = 0
arg1[-0xa].w = 0
sub_52e720(&arg1[-0xa], var_8_2, var_4_5)
void* eax_2 = entry_ebx + 0x56a90
arg1[-1].b = 7
arg1[-0x17] = 1
arg1[-0x36] = 0x31

if (eax_2 + 0xb8 != &arg1[-0x10])
    sub_52e3c0(eax_2 + 0xb8, &arg1[-0x10], 0, 0xffffffff)
    eax_2 = entry_ebx + 0x56a90

*(eax_2 + 0xd0) = 1
void var_80
int32_t var_84 = __builtin_memcpy(&var_80, &arg1[-0x36], 0x80)
int32_t var_88 = 0
char var_8c = 3
var_94 = &arg1[-0xa]
sub_60a340(eax_2, var_94, &arg1[-0xa], var_8c)

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

arg1[-1] = 0xffffffff
bool cond:0 = arg1[-0xb] u< 8
arg1[-5] = 7
arg1[-6] = 0
arg1[-0xa].w = 0

if (not(cond:0))
    j__free(arg1[-0x10])

sub_5cd760(entry_ebx + 0x56b64)
void* var_4_9 = 6
arg1[-5] = 7
wchar16 const* const var_8_4 = u"screen"
arg1[-6] = 0
arg1[-0xa].w = 0
sub_52e720(&arg1[-0xa], var_8_4, var_4_9)
arg1[-1] = 8
arg1[-0x17] = 1
arg1[-0x36] = 0x46
__builtin_memcpy(&var_80, &arg1[-0x36], 0x80)
sub_5fa690(entry_ebx + 0x61f5c, &arg1[-0xa], var_80)
arg1[-1] = 0xffffffff

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

sub_6a64d0(entry_ebx + 0x4b348)
sub_5fdee0(entry_ebx + 0x6217c)
void* var_4_11 = 8
arg1[-5] = 7
wchar16 const* const var_8_5 = u"pcmevent"
arg1[-6] = 0
arg1[-0xa].w = 0
sub_52e720(&arg1[-0xa], var_8_5, var_4_11)
arg1[-1] = 9
void* eax_5 = data_bac510
arg1[-0x17] = 1
arg1[-0x36] = 0x34
int32_t var_c_2 = *(eax_5 + 0xa4c764)
void* var_10_1 = &arg1[-0xa]
__builtin_memcpy(&var_94, &arg1[-0x36], 0x80)
sub_631e30(entry_ebx + 0x62634)
arg1[-1] = 0xffffffff

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

void* var_4_13 = 7
arg1[-5] = 7
wchar16 const* const var_8_6 = u"editbox"
arg1[-6] = 0
arg1[-0xa].w = 0
sub_52e720(&arg1[-0xa], var_8_6, var_4_13)
arg1[-1] = 0xa
void* eax_7 = data_bac510
arg1[-0x17] = 1
arg1[-0x36] = 0x61
void** ecx_16 = __builtin_memcpy(&var_80, &arg1[-0x36], 0x80)
int32_t var_8c_1 = *(eax_7 + 0xa4df80)
var_94 = ecx_16
sub_631f20(entry_ebx + 0x626ec, var_94, &arg1[-0xa])
arg1[-1] = 0xffffffff

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

void* var_4_15 = 4
arg1[-5] = 7
wchar16 const* const var_8_7 = u"call"
arg1[-6] = 0
arg1[-0xa].w = 0
sub_52e720(&arg1[-0xa], var_8_7, var_4_15)
arg1[-1] = 0xb
arg1[-0x17] = 1
arg1[-0x36] = 0x62
*(entry_ebx + 0x6285c) = 1
void* var_10_2 = &arg1[-0xa]
__builtin_memcpy(&var_94, &arg1[-0x36], 0x80)
sub_5b6750(entry_ebx + 0x627a4)
arg1[-1] = 0xffffffff

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

sub_52e820(&arg1[-0xa], u"excall")
arg1[-1] = 0xc
arg1[-0x17] = 1
arg1[-0x36] = 0x41
__builtin_memcpy(&var_80, &arg1[-0x36], 0x80)
sub_5ba0e0(entry_ebx + 0x62860, &arg1[-0xa])
arg1[-1] = 0xffffffff

if (arg1[-5] u>= 8)
    j__free(arg1[-0xa])

int16_t* var_4_19 = &data_af5d3c
*(entry_ebx + 0x4a76c) = 0
sub_52e820(&arg1[-0x16], var_4_19)
arg1[-1] = 0xd
sub_684160(data_bac424, 5, &arg1[-0x16])

if (arg1[-0x11] u>= 8)
    j__free(arg1[-0x16])

char* result
result.b = 1
TEB* fsbase
fsbase->NtTib.ExceptionList = arg1[-3]
sub_745f2b(arg1[-4] ^ arg1)
*arg1
return result

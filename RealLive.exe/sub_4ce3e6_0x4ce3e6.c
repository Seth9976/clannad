// 函数: sub_4ce3e6
// 地址: 0x4ce3e6
// 来自: F:\SETUPDATA\GAMEDATA\RealLive.exe

void* ebp = arg3 - 1
long double x87_r0 = arg6 * fconvert.t(*arg2)
int32_t eax
eax.b = *arg4
void* esi = &arg4[1]
void* entry_ebx
eax.b = *(entry_ebx + eax)
int32_t temp1 = *arg1
bool c
*arg1 = adc.d(temp1, esi, c)
bool c_1 = adc.d(temp1, esi, c) u< temp1 || (c && adc.d(temp1, esi, c) == temp1)
int32_t eflags
int32_t eflags_1 = __sti(eflags)
char temp0 = *(esi - 0x7b677d00)
*(esi - 0x7b677d00) = entry_ebx:1.b
entry_ebx:1.b = temp0
float** esp

if (arg1 == 0)
    *(eax - 0x1c281c80) = sbb.d(*(eax - 0x1c281c80), 0xffffffdc, c_1)
    
    while (true)
        ebp -= 1
        x87_r0 = x87_r0 * fconvert.t(*arg2)
        eax.b = *esi
        int32_t eflags_5
        char temp0_12
        char temp1_1
        temp0_12, temp1_1, eflags_5 = __aad_immb(0x11, eax.b, eax:1.b)
        eax.b = temp0_12
        eax:1.b = temp1_1
        entry_ebx ^= eax
        esi = 0x82988300
        
        if (arg1 != 0)
            break
        
        eax, arg2, arg1 = 0xac6291b0()
        char temp3_1 = eax.b
        eax.b -= 0xb
        bool p_1 = unimplemented  {sub al, 0xb}
        bool a_1 = unimplemented  {sub al, 0xb}
        *(esp - 4) = arg1
        char temp0_11 = *arg2
        *arg2 = arg1.b
        arg1.b = temp0_11
        bool d
        *(esp - 8) = (add_overflow(temp3_1, 0xf5) ? 1 : 0) << 0xb | (d ? 1 : 0) << 0xa
            | (temp3_1 - 0xb s< 0 ? 1 : 0) << 7 | (temp3_1 == 0xb ? 1 : 0) << 6
            | (a_1 ? 1 : 0) << 4 | (p_1 ? 1 : 0) << 2 | (temp3_1 u< 0xb ? 1 : 0)
        esp -= 8
        *(arg2 + (entry_ebx << 2)) = fconvert.d(x87_r0)
        *eax |= eax
        char temp4_1 = *(entry_ebx - 0x281c7f68)
        *(entry_ebx - 0x281c7f68) += eax.b
        
        if (arg1 == 0)
            if (temp4_1 + eax.b s< 0)
                eax.b += arg1[5].b
                undefined
            
            int32_t eax_2
            
            if (eax != 1)
                eax_2.b = __salc(eflags_5)
                undefined
            
            *esp
            eax_2.b = *0xdda78b77
            *esp = &esp[1]
            eax_2.b = __in_al_dx(arg2.w, eflags_5)
            int32_t eflags_4 = __cli(eflags_5)
            int32_t ebp_1
            int16_t ds_1
            ebp_1, ds_1 = __lds_gprz_memp(*(arg1 + 0x20513595))
            __in_oeax_dx(arg2.w, eflags_4)
            breakpoint
    
    *arg5
    breakpoint

eax.b = __salc(eflags_1)
int32_t eflags_2
int32_t eip
eip, eflags_2 = __into(eflags_1)
ebp -= 1
x87_r0 = x87_r0 * fconvert.t(*arg2)
eax.b = *esi
void* esi_1 = esi + 1
*arg1 = rlc.d(*arg1, 1, c_1)
arg2[-0x1f3fd05b]
arg2[-0x1f3fd05b] ^= arg5
char temp0_2 = entry_ebx.b
entry_ebx.b = sx.d(eax.w):1.b
eax:1.b = temp0_2
eax.b = *(entry_ebx + eax)
eax.b = *esi_1
esi = esi_1 + 1
*0xad84ddc = rlc.d(*0xad84ddc, 0xdc, false)
arg5 ^= eax
char temp0_3 = *(esi - 0x77677d00)
*(esi - 0x77677d00) = entry_ebx:1.b
entry_ebx:1.b = temp0_3
*arg5 = eax
void* edi = &arg5[1]
long double x87_r0_1 = x87_r0 * fconvert.t(*(ebp - 0x28))
arg1:1.b = *(ebp + (entry_ebx << 3) - 0x78ceceef)
void* esi_2 = 0x8a988300

while (true)
    float* edx = *esp
    char* eax_1
    eax_1.b = eax.w.b - 0x37
    int16_t ss
    *esp = zx.d(ss)
    eax_1.b = *(entry_ebx + eax_1)
    eax_1.b |= 0xb9
    eax = esi_2
    int16_t ds
    *(esp - 4) = zx.d(ds)
    esp -= 4
    arg1:1.b = 0x41
    int32_t temp9_1 = edx[-0xb99df34]
    edx[-0xb99df34] = temp9_1 u>> 1
    
    if (arg1 != 0)
        break
    
    *(eax - 0x54281c78) = sbb.d(*(eax - 0x54281c78), 0xffffffdc, (temp9_1 & 1) != 0)
    ebp -= 1
    x87_r0_1 = x87_r0_1 * fconvert.t(*edx)
    eax.b = *eax_1
    esi_2 = &eax_1[1]
    *arg1 = fconvert.d(x87_r0_1)
    *arg1 ^= esi_2
    char temp0_4 = *(esi_2 - 0x75677d00)
    *(esi_2 - 0x75677d00) = edi
    edi = temp0_4

int32_t eflags_3
char temp0_6
temp0_6, eflags_3 = __das(eax.b, eflags_2)
eax.b = temp0_6
undefined

// 函数: sub_4cae81
// 地址: 0x4cae81
// 来自: F:\SETUPDATA\GAMEDATA\RealLive.exe

void* entry_ebx
entry_ebx.b += arg1:1.b
arg1[0x13c70ad7].b -= entry_ebx:1.b
*(arg3 - 0x45b48329)
*(arg3 - 0x45b68329)
int32_t* esi_1 = arg5 - 2
arg1:1.b = 0x5c
int32_t ebp = arg4 - *(entry_ebx - 0x287627b1)
int32_t eflags

if (arg4 s>= *(entry_ebx - 0x287627b1))
    *(esi_1 - 0x4ab33dd9) = *(esi_1 - 0x4ab33dd9)
    *0x28e30000
    __out_immb_al(0xe9, arg1.b, eflags)
    int32_t edx
    int16_t ds
    edx, ds = __lds_gprz_memp(*arg3)
    *0x53600017 = arg1.b
    arg1.b = adc.b(arg1.b, 0xe, ebp u< 0x3c)
    int32_t eflags_1
    int32_t eip
    eip, eflags_1 = __into(eflags)
    *0x28e30002
    *arg1 += edx
    *0x443595ca = arg1.b
    int32_t eflags_2
    int32_t eip_1
    eip_1, eflags_2 = __into(eflags_1)
    *(arg3 - 0x29919fc4) = sbb.b(*(arg3 - 0x29919fc4), arg3:1.b, false)
    undefined

uint64_t* ecx = *0x539311ac
*0x28e30001 = *0x28e30001
*0x28e2fffd = ecx
*0x28e2fff9 = 0x5a852b5c
*0x28e2fff5 = entry_ebx
*0x28e2fff1 = 0x28e2fff5
*0x28e2ffed = ebp
*0x28e2ffe9 = esi_1
*0x28e2ffe5 = 0xbeea0b55
char temp3 = *(ecx - 0x15)
*(ecx - 0x15) += 0x5c
bool p = unimplemented  {add byte [ecx-0x15], dl}
bool a = unimplemented  {add byte [ecx-0x15], dl}
*0x28e2ffe1 = (add_overflow(temp3, 0x5c) ? 1 : 0) << 0xb | 0x400 | (temp3 + 0x5c s< 0 ? 1 : 0) << 7
    | (temp3 == 0xa4 ? 1 : 0) << 6 | (a ? 1 : 0) << 4 | (p ? 1 : 0) << 2
    | (temp3 + 0x5c u< temp3 ? 1 : 0)
unimplemented  {enter 0xfd7f, 0x44}
int32_t eax_4 = *0x28e2ffe1 - 2
int32_t temp5 = *(esi_1 + (ecx << 1) - 0x4a82671c)
*(esi_1 + (ecx << 1) - 0x4a82671c)
bool p_1 = unimplemented  {sub eax, dword [esi+ecx*2-0x4a82671c]}
bool a_1 = unimplemented  {sub eax, dword [esi+ecx*2-0x4a82671c]}
bool z_1 = eax_4 == temp5
bool s_1 = eax_4 - temp5 s< 0
bool o_1 = add_overflow(eax_4, neg.d(temp5))

while (z_1 || s_1 != o_1)
    int32_t* temp8_1 = esi_1
    esi_1 -= 1
    p_1 = unimplemented  {dec esi}
    a_1 = unimplemented  {dec esi}
    z_1 = temp8_1 == 1
    s_1 = temp8_1 - 1 s< 0
    o_1 = add_overflow(temp8_1, 0xffffffff)
    __in_al_immb(0x98, eflags)
    
    if (s_1 == o_1)
        undefined

char eax_5 = (s_1 ? 1 : 0) << 7 | (z_1 ? 1 : 0) << 6 | (a_1 ? 1 : 0) << 4 | (p_1 ? 1 : 0) << 2
    | (eax_4 u< temp5 ? 1 : 0)
*0x28e2ffe1 = entry_ebx
*0xbeea0b4b -= entry_ebx:1.b
bool p_2 = unimplemented  {or al, 0xc6}
bool a_2 = undefined
*0x28e2ffdd = 0x400 | ((eax_5 | 0xc6) s< 0 ? 1 : 0) << 7 | ((eax_5 | 0xc6) == 0 ? 1 : 0) << 6
    | (a_2 ? 1 : 0) << 4 | (p_2 ? 1 : 0) << 2
int32_t eax_6 = *esi_1
__out_immb_al(0xb4, eax_6.b, eflags)
int32_t edx_1
int16_t ds_1
edx_1, ds_1 = __lds_gprz_memp(*ecx)
int32_t temp10 = *0x28e2ffde
*0x28e2ffde += 0x28e2ffde
bool c_4 = temp10 + 0x28e2ffde u< temp10
*(eax_6 - 4) = 0x28e2ffde
*(eax_6 - 8) = ecx
*(eax_6 - 0xc) = edx_1
*(eax_6 - 0x10) = entry_ebx
*(eax_6 - 0x14) = eax_6 - 0x10
*(eax_6 - 0x18) = ebp
*(eax_6 - 0x1c) = esi_1 - 4
*(eax_6 - 0x20) = 0xbeea0b55
*(eax_6 - 0x24) = entry_ebx
char eax_7 = *0x89d96c4b
*(eax_6 - 0x28) = eax_6 - 0x24
*(eax_6 - 0x28)
__out_immb_al(0xb6, eax_7, eflags)
uint8_t* edi_1
uint8_t temp0_2
temp0_2, edi_1 = __insb(0x244435df, edx_1.w, eflags)
*edi_1 = temp0_2
int32_t eflags_3
int32_t eip_2
eip_2, eflags_3 = __into(eflags)
*(ecx - 0x2991bfc4) = sbb.b(*(ecx - 0x2991bfc4), ecx:1.b, 
    adc.b(0xde, 0x51, c_4) u< 0xde || (c_4 && adc.b(0xde, 0x51, c_4) == 0xde))
undefined
